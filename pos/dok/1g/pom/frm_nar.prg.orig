#include "\cl\sigma\fmk\pos\pos.ch"

*
*       Radi na _PRIPR (koju kasnije isprazni u _POS)
*

FUNCTION UnesiNarudzbu
PARAMETER cBrojRn, cSto

PRIVATE ImeKol, Kol, oBrowse, aAutoKeys := {}, nIznNar:=0, ;
       bPrevZv, bPrevKroz, aUnosMsg := {}, bPrevUp, bPrevDn
cBrojRn := IIF (cBrojRn == NIL, "", cBrojRn)

ImeKol:={ { "Sifra",      {|| IdRoba             }},;
          { "Naziv",      {|| Left (RobaNaz, 30) }},;
          { "JMJ",        {|| JMJ                }},;
          { "Kolicina  ", {|| STR (kolicina,8,2) }},;
          { "Cijena    ", {|| STR (Cijena,8,2)   }},;
          { "Iznos     ", {|| STR (Kolicina * Cijena,10,2)}};
        }
Kol:={1, 2, 3, 4, 5, 6}
AADD (aUnosMsg, "<*> - Ispravka stavke")
AADD (aUnosMsg, "Storno/povrat - negativna kolicina")
#IFDEF HOPS
  IF gRadniRac=="D"
    AADD (aUnosMsg, "</> - Pregled racuna")
  EndIF
#ENDIF
Box (, 20, 77, , aUnosMsg)
@ m_x,m_y+23 SAY PADC ("RACUN BR: "+Alltrim (cBrojRn), 40) COLOR Invert

oBrowse := FormBrowse ( m_x+6, m_y+1, m_x+19, m_y+77, ImeKol, Kol, ;
                    { "Í", "Ä", "³"}, 0)
oBrowse:autolite := .F.

aAutoKeys := HangKeys ()
bPrevDn := SETKEY (K_PGDN, {|| DummyProc()})
bPrevUp := SETKEY (K_PGUP, {|| DummyProc()})
// <*> - ispravka teku}e narud`be
//       (uklju~uju}i brisanje i ispravku vrijednosti)
// </> - pregled racuna - kod HOPSa
PostaviSpec ()
@ m_x+3,m_y+50 SAY "Ukupno:"
@ m_x+4,m_y+50 SAY "Popust:"
@ m_x+5,m_y+50 SAY "UKUPNO:"

#IFDEF HOPS
  IF gRadniRac == "D"
    SELECT _PRIPR
    IF RecCount2 ()>0
      GO TOP
      IF _PRIPR->IdRadnik <> gIdRadnik
        // u hopsu se radni racuni drze u _POS-u do zakljucenja
        _Pripr2_Pos ()
        SELECT _PRIPR
        Zapp(); __dbPack()
      EndIF
    EndIF
    // ako je vec poceo raditi, nek nastavi
    SELECT _POS    // PRIPR
    set order to 3    // "_POSi3", "IdVd+IdRadnik+GT+IdDio+IdOdj+IdRoba"
    Seek "42"+gIdRadnik+OBR_NIJE
    do while !eof() .and. _POS->(IdVd+IdRadnik+GT)==(VD_RN+gIdRadnik+OBR_NIJE)
      IF _POS->BrDok==cBrojRn    // _POS->Prebacen == OBR_NIJE
        Scatter()
        SELECT _PRIPR; Append Blank // _pripr
        Gather()     ; SELECT _POS
        Del_Skip()
      Else
        Skip
      EndIF
    EndDO
    set order to 1
  else
    // gRadniRac == "N";
    // prije ulaska u pripremu vrati u _PRIPR sve iz _POS sto nije "Z"-zakljuceno
    SELECT _POS; Set order to 3
    //"3", "IdVd+IdRadnik+GT+IdDio+IdOdj+IdRoba", PRIVPATH+"_POS"
    SEEK "42"+gIdRadnik
    DO While !eof() .and. _POS->(IdVd+IdRadnik)==(VD_RN+gIdRadnik)
      IF !(_POS->m1=="Z")
        // mora biti Z, jer se odmah zakljucuje
        Scatter()
        SELECT _PRIPR; Append Blank  // pripr
        Gather()
        SELECT _POS
        Del_Skip ()
      Else
        Skip
      EndIF
    EndDO
    set order to 1
  EndIF  // gradnirac
#ELSE
    // gRadniRac == "N";
    // prije ulaska u pripremu vrati u _PRIPR sve iz _POS sto nije "Z"-zakljuceno
    SELECT _POS; Set order to 3
    //"3", "IdVd+IdRadnik+GT+IdDio+IdOdj+IdRoba", PRIVPATH+"_POS"
    SEEK "42"+gIdRadnik
    DO While !eof() .and. _POS->(IdVd+IdRadnik)==(VD_RN+gIdRadnik)
      IF !(_POS->m1=="Z")
        // mora biti Z, jer se odmah zakljucuje
        Scatter()
        SELECT _PRIPR; Append Blank // pripr
        Gather()
        SELECT _POS
        Del_Skip ()
      Else
        Skip
      EndIF
    EndDO
    set order to 1
#ENDIF

nIznNar := 0
nPopust := 0
SELECT _PRIPR
GO TOP
do While ! Eof()
  if  (idradnik+idpos+idvd+smjena)<>(gIdRadnik+gidpos+VD_RN+gSmjena)
    delete  // _PRIPR
  else
    nIznNar += _PRIPR->(Kolicina*Cijena)
    nPopust += _PRIPR->(Kolicina*NCijena)
  endif
  SKIP
Enddo


Set order to; GO TOP
Scatter()                           // iz _PRIPR
_IdPos     := gIdPos
_IdVd      := VD_RN
_BrDok     := cBrojRn ;  _Datum     := gDatum
_Sto       := cSto    ;  _Smjena    := gSmjena
_IdRadnik  := gIdRadnik; _IdCijena  := gIdCijena
_Prebacen  := OBR_NIJE
_MU_I      := R_I

DO WHILE .T.
@ m_x+3,m_y+70 SAY nIznNar pict "99999.99" COLOR Invert
@ m_x+4,m_y+70 SAY nPopust pict "99999.99" COLOR Invert
@ m_x+5,m_y+70 SAY nIznNar-nPopust pict "99999.99" COLOR Invert


@ m_x+3,m_y+15 SAY SPACE (10)   // brisi staru cijenu

DO WHILE !oBrowse:Stabilize() .AND. ( (Ch := INKEY ()) == 0)
ENDDO
_idroba   := SPACE (LEN (_idroba))
_Kolicina := 0
@ m_x+2,m_y+25 SAY SPACE (40)

set cursor on

cDSFINI:=IzFMKINI('SifRoba','DuzSifra','10')

@ m_x+2,m_y+5 SAY " Artikal:" GET _idroba PICT "@!S10";
                  when {|| _idroba:=padr(_idroba,VAL(cDSFINI)),.t.} ;
                  VALID PostRoba(@_idroba, 2, 27) ;
                        .AND. NarProvDuple (_idroba)
@ m_x+3,m_y+5 SAY "  Cijena:" GET _Cijena  picture "99999.99" when (roba->tip=="T" .or. gPopZcj=="D")
@ m_x+4,m_y+5 SAY "Kolicina:" GET _Kolicina PICTURE "999999.999" ;
                  when {|| Popust(m_x+3,m_y+28),_kolicina:=iif(gOcitBarcod,1,_kolicina), _kolicina:=iif(_idroba='PLDUG  ',1,_kolicina), iif(_idroba='PLDUG  ',.f.,.t.) } ;
                  VALID KolicinaOK (_Kolicina) ;
                  SEND READER:={|g| GetReader2(g)}


// ako je sifra ocitana po barcodu, onda ponudi kolicinu 1

READ

cParticip:="N"
// apoteke !!!
select odj; hseek roba->idodj ; select _pripr
if right(odj->naz,5)=="#1#0#" ;
     .or. right(odj->naz,6)=="#1#50#"

     set cursor on
     @ m_x+4,m_y+25 SAY "particip:" GET cParticip pict "@!" valid cParticip $ "DN"
     read
     if cParticip=="D"
        _Ncijena:=1
     else
        _NCijena:=0
     endif
else
     @ m_x+4,m_y+25 SAY space (11)
endif



IF LASTKEY () = K_ESC
  EXIT
ELSE
 SELECT ODJ; HSEEK ROBA->IdOdj
 IF gVodiOdj=="N" .or. FOUND()
   SELECT _PRIPR; append blank // _prpr
   _RobaNaz := ROBA->Naz; _Jmj:= ROBA->Jmj
   _IdTarifa:= ROBA->IdTarifa
   if !(roba->tip=="T")
     _Cijena    := &("ROBA->Cijena"+gIdCijena)
   endif
   _IdOdj     := ROBA->IdOdj

   #ifdef HOPS
     IF gVodiTreb=="D" .and. ROBA->Tip <> "I"
     // I -inventar
       _GT := OBR_NIJE
       if gRadniRac=="D"; _M1:="S"; else; _M1:=" "; endif
     ELSE
       // za inventar se ne pravi trebovanje, ni u kom slucaju
       _GT := OBR_JEST
     ENDIF
     SELECT ROBAIZ;  HSEEK (_IdRoba)
     IF FOUND ()
       _IdDio := ROBAIZ->IdDio
     ELSE
       _IdDio := gIdDio
     ENDIF
     SELECT _PRIPR
   #endif

   Gather() // _PRIPR

   // utvrdi stanje racuna
   nIznNar += Cijena*Kolicina
   nPopust += NCijena*Kolicina

   oBrowse:goBottom()
   oBrowse:refreshAll()
   oBrowse:dehilite()
 else   // nije nadjeno odjeljenje ??
   SELECT _PRIPR
   #ifdef HOPS
     MsgBeep ("Za robu "+AllTrim (_IdRoba)+" nije odredjeno odjeljenje!#"+;
              "Narucivanje nije moguce!")
   #else
     MsgBeep ("Za robu "+AllTrim (_IdRoba)+" nije odredjeno odjeljenje!#"+;
              "Izdavanje nije moguce!")
   #endif
 endif
ENDIF
ENDDO

CancelKeys (aAutoKeys)
SETKEY (K_PGDN, bPrevDn)
SETKEY (K_PGUP, bPrevUp)
SkiniSpec ()

#IFDEF HOPS
IF gRadniRac == "D"
  SELECT _POS
  AppFrom ("_PRIPR", .F.)
  SELECT _PRIPR
  Zapp (); __dbPack()
EndIF
#ENDIF

BoxC()
RETURN (.T.)


function Popust(nx,ny)

local nC1:=0, nC2:=0

if gPopZcj=="D"
 // popust zadavanjem nove cijene
 if roba->tip <> "T"  // finansijsko rasknjizenje
  _ncijena:=round(  &("ROBA->Cijena"+gIdCijena) - _cijena, gPopDec)
  _cijena:= &("ROBA->Cijena"+gIdCijena)  // cijena iz sifrarnika
  nC1:=_cijena
  nC2:=_ncijena
 endif
else
 _ncijena:=round(_cijena*iif(gPopust=99,roba->n2,gPopust)/100, gPopDec)

 nC1:=_cijena
 nC2:=_ncijena
endif

if nC2<>0
  @ nx,ny SAY "Popust :"
  @ nx,col()+1 SAY _ncijena pict "99999.99"
  @ nx+1,ny SAY  "Cij-Pop:"
  @ nx+1,col()+1 SAY _cijena-_ncijena pict "99999.99"
else
  @ nx,ny   SAY  space(20)
  @ nx+1,ny SAY  space(20)
endif

//znaci nCijena:=  round( 100*10/100, 1) = 10
return

/***
*   HangKeys () --> aPrevSets
*      Nabacuje SETKEYs kako je tastatura programirana
*/
FUNCTION HangKeys ()
LOCAL aKeysProcs := {}, bPrevSet
  SELECT K2C
  GO TOP
  WHILE ! EOF()
    bPrevSet := SETKEY (KeyCode, {|| AutoKeys ()})
    AADD (aKeysProcs, { KeyCode, bPrevSet})
    SKIP
  END
RETURN ( aKeysProcs )


PROCEDURE CancelKeys (aPrevSets)
*   CancelKeys (aPrevSets)
*      Ukida SETKEYs koji se postave u HangKeys
*

LOCAL i := 1, nPrev := SELECT ()
SELECT K2C; GoTop2()
WHILE !EOF()
   SETKEY ( KeyCode, aPrevSets [i++] )
   SKIP
END
SELECT (nPrev)
RETURN

STATIC FUNCTION PostaviSpec ()
  bPrevZv   := SETKEY (ASC ("*"), {|| IspraviNarudzbu()})
#IFDEF HOPS
  // provjeriti parametar kako se vode racuni trgovacki ili hotelski
  IF gRadniRac == "D"
    bPrevKroz := SETKEY (ASC ("/"), { || PreglRadni (cBrojRn) })
  EndIF
#ENDIF
RETURN .T.


STATIC FUNCTION SkiniSpec ()

  SETKEY (ASC ("*"), bPrevZv)
#IFDEF HOPS
  IF gRadniRac =="D"
    SETKEY (ASC ("/"), bPrevKroz)
  EndIF
#ENDIF
RETURN .F.


*      Ako je u pitanju CrsrUp, onda skipuje provjeru
*      Provjerava robu na djeljivost

STATIC FUNCTION KolicinaOK (nKol)
local nSelect:=select()
local nStanje
LOCAL lFlag := .T.
IF LASTKEY() = K_UP
  RETURN .T.
ENDIF

IF nKol==0
   MsgBeep ("Nepravilan unos kolicine robe! Ponovite unos!", 15)
   RETURN .F.
ENDIF

IF ROBA->Djeljiv = "N" .AND. (INT (nKol) <> nKol)
   MsgBeep ( "Roba nije djeljiva!#"+ ;
             "Morate unijeti cijeli broj jedinica!!#Ponovite unos!", 20)
   RETURN (.F.)
ENDIF
// provjera ima li robe na stanju
IF gPratiStanje = "N" .or. roba->tip $ "TU"
   RETURN (.T.)
else
// gprati stanje D, !
#ifdef TOPS  // ovo cemo samo za TOPS!!
      select pos
      set order to 5  //"5", "IdPos+idroba+DTOS(Datum)", KUMPATH+"POS")
      seek _IdPos+_idroba
      nStanje:=0
      DO WHILE !eof() .and. POS->(IdPos+IdRoba)==(_IdPos+_IdRoba)
        IF POS->idvd $ "16#00"
          nStanje += POS->Kolicina
        ELSEIF Pos->idvd $ "IN"
          nStanje += POS->Kol2 - POS->Kolicina
        ELSEIF POS->idvd $ "42#01#96"
          nStanje -= POS->Kolicina
        ENDIF
        SKIP
      EndDO
      select pos; set order to 1
      select (nSelect)
      if nKol>nStanje
        MsgBeep("Trenutno na stanju artikla :"+_IdRoba+" "+str(nStanje,12,2))
        if gPratistanje="!"
           lFlag:=.f.
        endif
      endif
#endif
ENDIF
RETURN (lFlag)


STATIC FUNCTION NarProvDuple ()

LOCAL nPrevRec, lFlag := .T.
IF gDupliArt == "D" .and. gDupliUpoz == "N"
  // mogu dupli i nema upozorenja
  RETURN .T.
EndIF
SELECT _PRIPR
nPrevRec := RECNO ()

if _idroba='PLDUG  ' .and. reccount2()<>0
  return .f.
endif

set order to 1; seek 'PLDUG  '
if found()
   MsgBeep('PLDUG mora biti jedina stavka !')
   SET ORDER TO; GO (nPrevRec)
   return .f.
else
  set order to 1;  HSEEK _IdRoba
endif

IF FOUND()
  if _IdRoba='PLDUG'
      MsgBeep('Pri placanju duga ne mozete navoditi robu')
  endif
  IF gDupliArt == "N"
    MsgBeep ( "Na narudzbi se vec nalazi ista roba!#" +;
              "U slucaju potrebe ispravite stavku narudzbe!", 20)
    lFlag := .F.
  ElseIF gDupliUpoz == "D"
    MsgBeep ( "Na narudzbi se vec nalazi ista roba!")
  EndIF
ENDIF
SET ORDER TO
GO (nPrevRec)
RETURN (lFlag)


*
*Koristi privatnu varijablu oBrowse iz UNESINARUDZBU
*
PROCEDURE IspraviNarudzbu

LOCAL cGetId, nGetKol, aConds, aProcs
SkiniSpec ()

OpcTipke ({"<Enter>-Ispravi stavku", "<B>-Brisi stavku", ;
           "<Esc>-Zavrsi"})
oBrowse:autolite := .T.
oBrowse:configure()
// spasi ono sto je bilo u GET-u
cGetId  := _idroba
nGetKol := _Kolicina

aConds := { {|Ch| Ch == ASC ("b") .OR. Ch == ASC ("B")}, ;
            {|Ch| Ch == K_ENTER} ;
          }
aProcs := { {|| BrisStavNar (oBrowse)}, ;
            {|| EditStavNar (oBrowse)}  ;
          }
ShowBrowse (oBrowse, aConds, aProcs)

oBrowse:autolite := .F.
oBrowse:dehilite()
oBrowse:stabilize()

// vrati stari meni
Prozor0()
** OpcTipke (aUnosMsg)
// vrati sto je bilo u GET-u
_idroba := cGetId
_Kolicina := nGetKol

PostaviSpec ()
RETURN


FUNCTION BrisStavNar (oBrowse)
*
*   BrisStavNar ()
*       Brise stavku narudzbe
*       Koristi privatni parametar OBROWSE iz SHOWBROWSE
*

SELECT _PRIPR
IF RecCount2 () == 0
  MsgBeep ("Narudzba nema nijednu stavku!#Brisanje nije moguce!", 20)
  RETURN (DE_REFRESH)
ENDIF
Beep (2)
nIznNar -= _PRIPR->(Kolicina*Cijena)
nPopust -= _PRIPR->(Kolicina*NCijena)
@ m_x+4,m_y+61 SAY nIznNar pict "99999.99" COLOR Invert
DELETE    // _PRIPR
oBrowse:refreshAll()
DO WHILE !oBrowse:stable ; oBrowse:Stabilize(); enddo
RETURN (DE_REFRESH)


FUNCTION EditStavNar (oBrowse)
*
*
*      Vrsi editovanje stavke narudzbe, i to samo artikla ili samo kolicine
*      Koristi privatni parametar OBROWSE iz SHOWBROWSE
*

PRIVATE GetList := {}
SELECT _PRIPR
IF RecCount2() == 0
  MsgBeep ("Narudzba nema nijednu stavku!#Ispravka nije moguca!", 20)
  RETURN (DE_CONT)
ENDIF
Scatter()

set cursor on
Box (, 3, 75)
@ m_x+1,m_y+4 SAY "   Artikal:" GET _idroba PICTURE "@K" ;
                  VALID PostRoba(@_idroba, 1, 27) .AND. ;
                        (_IdRoba==_PRIPR->IdRoba .OR. NarProvDuple ())
@ m_x+2,m_y+3 SAY "     Cijena:" GET _Cijena  picture "99999.99" when roba->tip=="T"
@ m_x+3,m_y+3 SAY "   kolicina:" GET _Kolicina;
                  VALID KolicinaOK (_Kolicina)
READ

cParticip:="D"
if _ncijena==0
  cParticip:="N"
endif
// apoteke !!!
select odj; hseek roba->idodj ; select _pripr
if right(odj->naz,5)=="#1#0#" ;
     .or. right(odj->naz,6)=="#1#50#"

     set cursor on
     @ m_x+3,m_y+25 SAY "particip:" GET cParticip pict "@!" valid cParticip $ "DN"
     read
     if cParticip=="D"
        _Ncijena:=1
     else
        _NCijena:=0
     endif
else
    @ m_x+3,m_Y+25  SAY space(11)
endif


IF LastKey()<>K_ESC
  IF (_PRIPR->IdRoba<>_IdRoba) .or. roba->tip=="T"
    SELECT ODJ
    HSEEK ROBA->IdOdj
    // LOCATE FOR IdTipMT == ROBA->IdTreb
    IF FOUND ()
      SELECT _PRIPR
      _RobaNaz    := ROBA->Naz
      _JMJ        := ROBA->JMJ
      if !(roba->tip=="T")
       _Cijena     := &("ROBA->Cijena"+gIdCijena)
      endif
      _IdTarifa   := ROBA->IdTarifa
      _IdOdj      := ROBA->IdOdj
      nIznNar+=(_cijena*_kolicina)  - cijena*kolicina
      nPopust+=(_ncijena*_kolicina)  - ncijena*kolicina
      Gather () //_PRIPR
    ELSE
      MsgBeep ("Za robu "+ALLTRIM (_IdRoba)+" nije odredjeno odjeljenje!#"+;
               "Narucivanje nije moguce!!!", 15)
      SELECT _PRIPR
      RETURN (DE_CONT)
    ENDIF
  ENDIF
  IF _PRIPR->Kolicina <> _Kolicina
     // azuriraj narudzbu
     nIznNar+=(_cijena*_kolicina) - cijena*kolicina
     nPopust+=(_ncijena*_kolicina) - ncijena*kolicina
     REPLACE Kolicina WITH _Kolicina
  ENDIF
  if gPopVar=="A" .and. _PRIPR->ncijena<> _NCijena
     // samo za apoteke
     replace ncijena with _ncijena
  endif
EndIF
BoxC()
@ m_x+3,m_y+70 SAY nIznNar pict "99999.99" COLOR Invert
@ m_x+4,m_y+70 SAY nPopust pict "99999.99" COLOR Invert
@ m_x+5,m_y+70 SAY nIznNar-nPopust pict "99999.99" COLOR Invert
oBrowse:refreshCurrent()
DO WHILE !oBrowse:stable ; oBrowse:Stabilize(); enddo

RETURN (DE_CONT)


/***
*
*  GetReader( <oGet>, <GetList>, <oMenu>, <aMsg> )
*
*  Standard modal read of a single GET
*
***/
PROCEDURE GetReader2( oGet, GetList, oMenu, aMsg )
  LOCAL nKey, nRow, nCol

  // Read the GET if the WHEN condition is satisfied
  IF ( GetPreValidate( oGet, aMsg ) )

     //ShowGetMsg( oGet, aMsg )
     // Activate the GET for reading

     //saStatics[ SNHITCODE ] := 0
     oGet:setFocus()

     WHILE (  oGet:exitState == GE_NOEXIT )
         //.AND.
         //!saStatics[ SLKILLREAD ] )

        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        if (gOcitBarcod .and. gEntBarCod=="D")
           oGet:exitState:=GE_ENTER
           exit
        endif

        // Check for initial typeout (no editable positions)
        IF ( oGet:typeOut )
           oGet:exitState := GE_ENTER
        ENDIF

        // Apply keystrokes until exit
        WHILE ( oGet:exitState == GE_NOEXIT )
          //.AND. !saStatics[ SLKILLREAD ] )
           //SETCURSOR( SC_NORMAL )
           nKey := INKEY( 0 )
           //SETCURSOR( SC_NONE )
           GetApplyKey( oGet, nKey, GetList, oMenu, aMsg )
           nRow := ROW()
           nCol := COL()
           //ShowGetMsg( oGet, aMsg )
           DevPos( nRow, nCol )
        ENDDO

        // Disallow exit if the VALID condition is not satisfied
        IF ( !GetPostValidate( oGet, aMsg ) )
           oGet:exitState := GE_NOEXIT
        ENDIF

     ENDDO

     // De-activate the GET
     oGet:killFocus()


  ENDIF

RETURN


